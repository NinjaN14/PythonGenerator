# This is for Python 2.7. Alternator has lowest precedence.

single_input -> NEWLINE
single_input -> simple_stmt
single_input -> compound_stmt NEWLINE

file_input -> newline_or_stmt_sp ENDMARKER
newline_or_stmt_sp -> newline_or_stmt newline_or_stmt_sp
newline_or_stmt_sp -> EMPTYSTRING
newline_or_stmt -> NEWLINE
newline_or_stmt -> stmt

eval_input -> testlist newline_sp ENDMARKER
newline_sp -> NEWLINE newline_sp
newline_sp -> EMPTYSTRING

decorator -> '@' dotted_name paren_arglist NEWLINE
decorator -> '@' dotted_name NEWLINE
paren_arglist -> '(' arglist ')'
paren_arglist -> '(' ')'
decorators -> decorator decorator_sp
decorator_sp -> decorator decorator_sp
decorator_sp -> EMPTYSTRING
decorated -> decorators classdef_or_funcdef
classdef_or_funcdef -> classdef
classdef_or_funcdef -> funcdef
funcdef -> 'def' NAME parameters ':' suite

parameters -> '(' varargslist ')'
parameters -> '(' ')'
varargslist -> varargslist_one
varargslist -> varargslist_two
varargslist_one -> fpdef_equal_sign_and_test_comma_sp args_kwargs_or_kwargs
varargslist_two -> fpdef_equal_sign_and_test comma_fpdef_equal_sign_and_test_sp opt_comma
fpdef_equal_sign_and_test_comma_sp -> fpdef_equal_sign_and_test_comma fpdef_equal_sign_and_test_comma_sp
fpdef_equal_sign_and_test_comma_sp -> EMPTYSTRING
comma_fpdef_equal_sign_and_test_sp -> comma_fpdef_equal_sign_and_test comma_fpdef_equal_sign_and_test_sp
comma_fpdef_equal_sign_and_test_sp -> EMPTYSTRING
opt_comma -> ','
opt_comma -> EMPTYSTRING
comma_fpdef_equal_sign_and_test -> ',' fpdef_equal_sign_and_test
fpdef_equal_sign_and_test_comma -> fpdef_equal_sign_and_test ','
fpdef_equal_sign_and_test -> fpdef equal_sign_and_test
fpdef_equal_sign_and_test -> fpdef
equal_sign_and_test -> '=' test
args_kwargs_or_kwargs -> args_with_opt_kwargs
args_kwargs_or_kwargs -> kwargs
args_with_opt_kwargs -> args ',' kwargs
args_with_opt_kwargs -> args
args -> '*' NAME
kwargs -> '**' NAME
fpdef -> NAME
fpdef -> '(' fplist ')'
fplist -> fpdef comma_fpdef_sp opt_comma
comma_fpdef -> ',' fpdef
comma_fpdef_sp -> comma_fpdef comma_fpdef_sp
comma_fpdef_sp -> EMPTYSTRING

stmt -> simple_stmt
stmt -> compound_stmt
simple_stmt -> small_stmt semicolon_small_stmt opt_semicolon NEWLINE
simple_stmt -> small_stmt opt_semicolon NEWLINE
small_stmt -> expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | exec_stmt | assert_stmt
expr_stmt -> testlist augassign_yldexpr_testlist
expr_stmt -> testlist assign_yldexpr_testlist
opt_semicolon -> ';'
opt_semicolon -> EMPTYSTRING
semicolon_small_stmt -> ';' small_stmt
semicolon_small_stmt -> semicolon_small_stmt ';' small_stmt
yldexpr_testlist -> yield_expr | testlist
augassign_yldexpr_testlist -> augassign yldexpr_testlist
assign_yldexpr_testlist -> '=' yldexpr_testlist
assign_yldexpr_testlist -> assign_yldexpr_testlist '=' yldexpr_testlist

augassign -> '+='
augassign -> '-='
augassign -> '*='
augassign -> '/='
augassign -> '%='
augassign -> '&='
augassign -> '|='
augassign -> '^='
augassign -> '<<='
augassign -> '>>='
augassign -> '**='
augassign -> '//='

# For normal assignments, additional restrictions enforced by the interpreter
print_stmt -> 'print' test comma_test_star opt_comma
print_stmt -> 'print'
print_stmt -> 'print' '>>' test comma_test_plus opt_comma
print_stmt -> 'print' '>>' test
comma_test -> ',' test
comma_test_star -> EMPTYSTRING
comma_test_star -> comma_test comma_test_star
comma_test_plus -> comma_test comma_test
comma_test_plus -> comma_test
del_stmt -> 'del' exprlist
pass_stmt -> 'pass'
flow_stmt -> break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
break_stmt -> 'break'
continue_stmt -> 'continue'
return_stmt -> 'return' opt_testlist
opt_testlist -> testlist
opt_testlist -> EMPTYSTRING
yield_stmt -> yield_expr
raise_stmt -> 'raise'
raise_stmt -> 'raise' test
raise_stmt -> 'raise' test ',' test opt_comma_test
opt_comma_test = ',' test
opt_comma_test -> EMPTYSTRING
import_stmt -> import_name | import_from
import_name -> 'import' dotted_as_names
import_from -> 'from' from_import_agent 'import' from_importee
from_importee -> '*'
from_importee -> '(' import_as_names ')'
from_importee -> import_as_names
from_import_agent -> dot_star dotted_name
from_import_agent -> dot_plus
dot -> '.'
dot_star -> EMPTYSTRING
dot_star -> dot
dot_star -> dot dot_star
dot_plus -> dot dot_star

import_as_name -> NAME
import_as_name -> NAME 'as' NAME
dotted_as_name -> dotted_name
dotted_as_name -> dotted_name 'as' NAME
import_as_names -> import_as_name opt_comma
import_as_names -> import_as_name cian_plus opt_comma
cian_plus -> ',' import_as_name
cian_plus -> cian_plus ',' import_as_name
dotted_as_names -> dotted_as_name
dotted_as_names -> dotted_as_name cdan_plus
cdan_plus -> ',' dotted_as_name
cdan_plus -> cdan_plus ',' dotted_as_name
dotted_name -> NAME
dotted_name -> NAME dot_name_plus
dot_name_plus -> '.' NAME
dot_name_plus -> dot_name_plus '.' NAME
global_stmt -> 'global' NAME
global_stmt -> 'global' NAME comma_name_plus
comma_name_plus -> ',' NAME
comma_name_plus -> comma_name_plus ',' NAME
exec_stmt -> 'exec' expr
exec_stmt -> 'exec' expr 'in' test opt_comma_test
assert_stmt -> 'assert' test opt_comma_test

compound_stmt -> if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated

if_stmt -> 'if' test ':' suite elif_test_suite 'else' ':' suite
if_stmt -> 'if' test ':' suite elif_test_suite
elif_test_suite -> EMPTYSTRING
elif_test_suite -> 'elif' test ':' suite
elif_test_suite -> 'elif' test ':' suite elif_test_suite

while_stmt -> 'while' test ':' suite 'else' ':' suite
while_stmt -> 'while' test ':' suite

for_stmt -> 'for' exprlist 'in' testlist ':' suite 'else' ':' suite
for_stmt -> 'for' exprlist 'in' testlist ':' suite
try_stmt -> 'try' ':' suite ex_clause_suite_plus opt_else_colon_suite opt_fly_colon_suite
try_stmt -> 'try' ':' suite 'finally' ':' suite
opt_else_colon_suite -> 'else' ':' suite
opt_else_colon_suite -> EMPTYSTRING
opt_fly_colon_suite -> 'finally' ':' suite
opt_fly_colon_suite -> EMPTYSTRING
ex_clause_suite_plus -> except_clause ':' suite
ex_clause_suite_plus -> ex_clause_suite_plus except_clause ':' suite


with_stmt -> 'with' with_item comma_with_item_star  ':' suite
comma_with_item_star -> EMPTYSTRING
comma_with_item_star -> ',' with_item
comma_with_item_star -> ',' with_item comma_with_item_star
with_item -> test 'as' expr
with_item -> test

# NB compile.c makes sure that the default except clause is last
except_clause -> 'except' test 'as' test
except_clause -> 'except' test ',' test
except_clause -> 'except' test
except_clause -> 'except'
suite -> simple_stmt | NEWLINE INDENT stmt_plus DEDENT
stmt_plus -> stmt
stmt_plus -> stmt stmt_plus

# Backward compatibility cruft to support:
# [ x for x in lambda: True, lambda: False if x() ]
# even while also allowing:
# lambda x: 5 if x else 2
# (But not a mix of the two)
testlist_safe -> old_test cold_test_plus ','
testlist_safe -> old_test cold_test_plus
testlist_safe -> old_test
cold_test_plus -> ',' old_test
cold_test_plus -> ',' old_test cold_test_plus
old_test -> or_test | old_lambdef
old_lambdef -> 'lambda' varargslist ':' old_test
old_lambdef -> 'lambda' ':' old_test

test -> or_test 'if' or_test 'else' test
test -> or_test
test -> lambdef

or_test -> and_test orand_test_star
orand_test_star -> EMPTYSTRING
orand_test_star -> 'or' and_test
orand_test_star -> 'or' and_test orand_test_star

and_test -> not_test andnot_test_star
andnot_test_star -> EMPTYSTRING
andnot_test_star -> 'and' not_test
andnot_test_star -> 'and' not_test andnot_test_star

not_test -> 'not' not_test
not_test -> comparison

comparison -> expr comp_op_expr_star
comp_op_expr_star -> EMPTYSTRING
comp_op_expr_star -> comp_op expr
comp_op_expr_star -> comp_op expr comp_op_expr_star
comp_op -> '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'

expr -> xor_expr pipe_xor_expr_star
pipe_xor_expr_star -> EMPTYSTRING
pipe_xor_expr_star -> '|' xor expr
pipe_xor_expr_star -> '|' xor expr pipe_xor_expr_star

xor_expr -> and_expr hat_and_expr_star
hat_and_expr_star -> EMPTYSTRING
hat_and_expr_star -> '^' and_expr
hat_and_expr_star -> '^' and_expr hat_and_expr_star

and_expr -> shift_expr amp_shift_expr_star
amp_shift_expr_star -> EMPTYSTRING
amp_shift_expr_star -> '&' shift_expr
amp_shift_expr_star -> '&' shift_expr amp_shift_expr_star

shift_expr -> arith_expr doubles_arith_expr_star
doubles_arith_expr_star -> EMPTYSTRING
doubles_arith_expr_star -> '<<' arith_expr
doubles_arith_expr_star -> '<<' arith_expr doubles_arith_expr_star
doubles_arith_expr_star -> '>>' arith_expr
doubles_arith_expr_star -> '>>' arith_expr doubles_arith_expr_star

arith_expr -> term pm_term_star
pm_term_star -> EMPTYSTRING
pm_term_star -> '+' term'
pm_term_star -> '+' term' pm_term_star
pm_term_star -> '-' term'
pm_term_star -> '-' term' pm_term_star

term -> factor times_factor_star
times_factor_star -> EMPTYSTRING
times_factor_star -> times_factor factor
times_factor_star -> times_factor factor times_factor_star
times_factor -> '*'|'/'|'%'|'//'

factor -> '+' factor | power
factor -> '-' factor | power
factor -> '~' factor | power
power -> atom trailer_star '**' factor
power -> atom trailer_star
trailer_star -> EMPTYSTRING
trailer_star -> trailer
trailer_star -> trailer trailer_star

atom -> '(' testlist_comp ')'
atom -> '(' yield_expr ')'
atom -> '(' ')'
atom -> '[' listmaker ']'
atom -> '[' ']'
atom -> '{' dictorsetmaker '}'
atom -> '{' '}'
atom -> '`' testlist1 '`'
atom -> NAME
atom -> NUMBER
atom -> string_plus
string_plus -> STRING
string_plus -> STRING string_plus


listmaker -> test list_for 
listmaker -> test comma_test_star opt_comma

testlist_comp -> test comp_for
testlist_comp -> test comma_test_star opt_comma

lambdef -> 'lambda' varargslist ':' test
lambdef -> 'lambda' ':' test

trailer -> '(' [arglist] ')'
trailer -> '[' subscriptlist ']'
trailer -> '.' NAME

subscriptlist -> subscript comma_subscript_star opt_comma
comma_subscript_star -> EMPTYSTRING
comma_subscript_star -> ',' subscript
comma_subscript_star -> ',' subscript comma_subscript_star

subscript -> '.' '.' '.' 
subscript -> test
subscript -> test ':' test_sliceop_2opt
subscript -> ':' test_sliceop_2opt
test_sliceop_2opt -> EMPTYSTRING
test_sliceop_2opt -> test
test_sliceop_2opt -> sliceop
test_sliceop_2opt -> test sliceop


sliceop -> ':' test
sliceop -> ':'
exprlist -> expr comma_expr_star opt_comma
comma_expr_star -> EMPTYSTRING
comma_expr_star -> ',' expr
comma_expr_star -> ',' expr comma_expr_star

testlist -> test comma_test_star opt_comma
dictorsetmaker -> test ':' test comma_testCtest_star opt_comma
dictorsetmaker -> test ':' test comp_for 
dictorsetmaker -> test comp_for
dictorsetmaker -> test comma_test_star opt_comma
comma_testCtest_star -> EMPTYSTRING
comma_testCtest_star -> ',' test ':' test
comma_testCtest_star -> ',' test ':' test comma_testCtest_star

classdef -> 'class' NAME '(' [testlist] ')' ':' suite
classdef -> 'class' NAME ':' suite

arglist -> arg_comma_star argument opt_comma
arglist -> arg_comma_star '*' test comma_arg_star ',' '**' test
arglist -> arg_comma_star '*' test comma_arg_star 
arglist -> arg_comma_star '**' test
arg_comma_star -> EMPTYSTRING
arg_comma_star -> argument ','
arg_comma_star -> argument ',' arg_comma_star
comma_arg_star -> EMPTYSTRING
comma_arg_star -> ',' argument
comma_arg_star -> ',' argument comma_arg_star

# The reason that keywords are test nodes instead of NAME is that using NAME
# results in an ambiguity. ast.c makes sure it's a NAME.
argument -> test comp_for
argument -> test
argument -> test '=' test

list_iter -> list_for | list_if
list_for -> 'for' exprlist 'in' testlist_safe list_iter
list_for -> 'for' exprlist 'in' testlist_safe

list_if -> 'if' old_test list_iter
list_if -> 'if' old_test

comp_iter -> comp_for | comp_if
comp_for -> 'for' exprlist 'in' or_test comp_iter
comp_for -> 'for' exprlist 'in' or_test
comp_if -> 'if' old_test comp_iter
comp_if -> 'if' old_test

testlist1 -> test comma_test_star

# not used in grammar, but may appear in "node" passed from Parser to Compiler
encoding_decl -> NAME

yield_expr -> 'yield' testlist
yield_expr -> 'yield'

EMPTYSTRING -> ''