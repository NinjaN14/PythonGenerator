import os
import sys
import Numeric
import string
import subprocess
from storm.locals import *
from libcvsanaly2.FindProgram import find_program
from libcvsanaly2.Database import *


"""
Data generated by this module can be displayied by using gnulplot:

% gnuplot
#set contour surface
#set palette gray
unset contour
set pm3d
unset surface
set ticslevel 0
set xlabel "Periods"
set ylabel "History (periods)"
set zlabel "Commits"
splot "matrix_top_commiters" with lines

It can be later output to a EPS file by:

set terminal postscript
set out "/tmp/draw.eps"
set view 36,41
splot "matrix_top_commiters" with lines
"""



class period:
    """
    Root class for kinds of periods.

    Initializes the template for producing a view of the database
    specific for a given kind of period (quarters, number of days, etc.)
    """
    
    def name(self):
        raise NotImplementedError
    
    def queryTemplate(self):
        raise NotImplementedError
    
class periodQuarter (period):
    """
    Class for specifying quarters as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a quarter)
    #  The use of firstDate is for normalizing (first period will be 0)
    queryCreateTemplate = string.Template ("""
    select year(s.date)*4+quarter(s.date)-year("$firstDate")*4-quarter("$firstDate") period, s.committer_id, count(distinct(s.id))
    from scmlog s, actions a, file_types ft 
    where a.commit_id = s.id and a.file_id = ft.file_id and ft.type in ('unknown', 'code') 
    group by period, s.committer_id
    order by period, count(s.date) desc;
    """)
    
    def __init__(self):
        pass

    def name(self):
        return "quarters"

    def queryTemplate(self):
        return self.queryCreateTemplate
    
class periodDays (period):
    """
    Class for specifying a number of days as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a number of days)
    #  The use of firstDate is for normalizing (first period will be 0)
    #  days is the number of days for each period
    queryCreateTemplateDays = string.Template ("""
    select (to_days(s.date) - to_days("$firstDate")) div $days period, s.committer_id, count(distinct(s.id))
    from scmlog s, actions a, file_types ft
    where a.commit_id = s.id and a.file_id = ft.file_id and ft.type in ('unknown', 'code')
    group by period, s.committer_id
    order by period, count(s.date) desc;
    """)

    def __init__(self, days):
        self.days = days
        self.queryCreateTemplate = string.Template(
          self.queryCreateTemplateDays.safe_substitute (days=days))
        
    def name(self):
        return "days_" + str (self.days)
    
    def queryTemplate(self):
        return self.queryCreateTemplate

class periodSlots (period):
    """
    Class for specifying the number of slots (periods) as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a number of days)
    #  The use of firstDate is for normalizing (first period will be 0)
    #  days is the number of days for each period
    queryCreateTemplateSlots = string.Template ("""
    select (to_days(s.date) - to_days("$firstDate")) div ((to_days("$lastDate") - to_days("$firstDate")) div $slots) period, s.committer_id, count(distinct(s.id))
    from scmlog s, actions a, file_types ft
    where a.commit_id = s.id and a.file_id = ft.file_id and ft.type in ('unknown', 'code')
    group by period, s.committer_id
    order by period, count(s.date) desc;
    """)

    def __init__(self, slots):
        self.slots = slots
        self.queryCreateTemplate = string.Template(
          self.queryCreateTemplateSlots.safe_substitute (slots=slots))
        
    def name(self):
        return "slots_" + str (self.slots)
    
    def queryTemplate(self):
        return self.queryCreateTemplate


class generations:

    connection = None

    def __init__(self, in_db, out_db, dirname, periodKind):
        # result = db.querySQLRaw ("select from_days((to_days(date_log) div 100)*100) as period, count(*) from log group by period")
        # result = db.querySQLRaw ("drop view generations")

        # Connection to the database
        in_store = Store (in_db)
        self.out_store = Store (out_db)

        # Period name
        self.periodName = periodKind.name()
        
        # Directory to store results
        self.dirname = os.path.join (dirname, self.periodName)

        # Dictionary with commits per period
        self.commitsPeriodDict = {}
        # Dictionary with commiters per period
        self.commitersPeriodDict = {}
        
        # Get earliest date from the log table
        result = in_store.execute ("select min(date) from scmlog")
        data = [item for item in result]
        self.firstDate = data[0][0]
        
        # Get latest date from the log table
        result = in_store.execute ("select max(date) from scmlog")
        data = [item for item in result]
        self.lastDate = data[0][0]

        # Create the table
        self.out_store.execute ('create table %s (' % (self.periodName) +
                                'id integer auto_increment, ' +
                                'period integer, ' +
                                'committer_id integer, ' +
                                'n_commits integer, ' +
                                'PRIMARY KEY (id)' +
                                ')', noresult=True)
        
        # Produce SQL code for filling the table, based on the template
        queryCreateTemplate = periodKind.queryTemplate()
        queryCreate = queryCreateTemplate.substitute (firstDate=self.firstDate,
                                                      lastDate=self.lastDate)
        result = in_store.execute (queryCreate)
        for period, committer_id, n_commits in result:
            self.out_store.execute ('insert into %s ' % (self.periodName) +
                                    '(period, committer_id, n_commits) ' +
                                    'values (?, ?, ?)',
                                    (period, committer_id, n_commits),
                                    True)
        self.out_store.commit ()

        in_store.close ()
        
        try:
            os.makedirs (self.dirname)
        except:
            print dirname + " already exists, not creating"

        # Generations database view, as an array of rows
        # Each row is period (starting at 0), commiter, commits.
        # Ordered by period, commits (descending)
        result = self.out_store.execute ("select period, committer_id, n_commits from %s" % (self.periodName))
        self.periodCommitsCommiter = [item for item in result]
        self.lastPeriod = int (self.periodCommitsCommiter[-1][0])

        # Perform all the analysis
        print ('Performing analysis with period=' + periodKind.name())
        self.commitsPerPeriodPerCommiter()
        self.commitsPerPeriod()
        self.largestCommiters()
        self.topFractionCommits(0.1)
        self.topFractionCommits(0.5)
        self.topFractionCommits(1.0)
        self.topFractionCommiters(0.1)
        self.topFractionCommiters(0.2)
        self.topFractionCommiters(1.0)

        self.out_store.close ()

    def commitsPerPeriodPerCommiter(self):

        """
        Print lines to a file, each line repesenting:
          period commiter commits
        """
        
        filehand = open(self.dirname + '/' + 'commits_per_period_per_commiter', 'w')
        
        for row in self.periodCommitsCommiter:
            # 0:period, 2:commiter, 3:commits
            filehand.write ('%d %d %d\n' % (row[0], row[1], row[2]))


    def commitsPerPeriod(self):

        """
        Print lines to a file, each line representing:
          period commits commiters
        Also, fills in self.commitsPeriodDict (commits per period)
        and self.commitersPeriodDict (commiters per period)
        """
        
        filehand = open(self.dirname + '/' + 'data_per_period', 'w')

        # Commits per period, as an array of rows
        commitsPeriod = self.out_store.execute ("select period, sum(n_commits), count(committer_id) " +
                                                "from %s " % (self.periodName) +
                                                "group by period")
        for row in commitsPeriod:
            # 0:period, 1:commits, 2: commiters
            filehand.write ('%d %d %d\n' % (row[0], row[1], row[2]))
            self.commitsPeriodDict [int(row[0])] = int(row[1])
            self.commitersPeriodDict [int(row[0])] = int(row[2])

    def largestCommiters(self):

        """
        Get, for each period, the largest commiter, and trace her
        history (commits in any other period)
        """
        
        print ('- Generating matrix for largest commiters')
        file = self.dirname + '/' + 'matrix_top_commiters'

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            if period > currentPeriod:
                # This row corresponds to the largest commiter in a new period
                currentPeriod = period
                commiter = row[1]
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)

    def topFractionCommits(self, fraction):

        """
        Get, for each period, the commiters producing the top fraction
        of the commits, and trace their history (commits in any other
        period for all of them)

        fraction should be between 0 and 1
        """

        print ('- Generating matrix for commiters producing ' + \
              'top fraction of commits (fraction: ' + \
              str (fraction))
        file = self.dirname + '/' + 'matrix_top_fraction_commits-' + \
               str (fraction)

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            commiter = row[1]
            if period > currentPeriod:
                # This row corresponds to a new period,
                #  init. values for new period
                currentPeriod = period
                currentCommits = 0
            if currentCommits < self.commitsPeriodDict[period] * fraction:
                # Still not all commiters wanted for this period,
                #   add this one
                currentCommits = currentCommits + int(row[2])
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)

    def topFractionCommiters(self, fraction):

        """
        Get, for each period, the top fraction of commiters, and
        trace their history (commits in any other period for all
        of them)

        fraction should be between 0 and 1
        """
        
        print ('- Generating matrix for top fraction of commiters ' + \
               '(fraction: ' + \
               str (fraction) + ')')
        file = self.dirname + '/' + 'matrix_top_fraction_commiters-' + \
               str (fraction)

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            commiter = row[1]
            if period > currentPeriod:
                # This row corresponds to a new period,
                #  init. values for new period
                currentPeriod = period
                currentCommiters = 0
            if currentCommiters < self.commitersPeriodDict[period] * fraction:
                # Still not all commiters wanted for this period,
                #   add this one
                currentCommiters = currentCommiters + 1
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)


    def commitsCommiterAllPeriods(self, commiter, arrayCommits):

        """
        Calculate the number of commits per period, for all periods,
        for a given commiter, and produce an add that information
        to the given arrayCommits (which should be zeroed before
        calling this function in case this is the first call to fill
        it in).
        """
        
        # print arrayCommits
        result = self.out_store.execute ("select period, sum(n_commits) from %s " % (self.periodName) +
                                         "where committer_id=? group by period", (commiter,))
        for row in result:
            # 0:period, 1:commits
            period = int (row[0])
            arrayCommits [period] = arrayCommits [period] + int(row[1])

    def outputMatrix(self, matrix, file):

        """
        Matrix is two dimensional, with a value for each position.
        Output it to a file suitable for being shown by gnuplot.
        Both absolute and normalized (by the number of commits per period)
        matrices are produced.
        """

        filehand = open(file, 'w')

        for x in range(0, len(matrix)-1):
            for y in range(0, len(matrix[x])-1):
                filehand.write (str(x) + ' ' + str(y) + ' ' + str(matrix[x,y]) + '\n')
            filehand.write ('\n')

        filehand.close()

        self.plot (file)

        filehand = open(file + '-normal', 'w')

        for x in range(0, len(matrix)-1):
            for y in range(0, len(matrix[x])-1):
                if y in self.commitsPeriodDict:
                    commitsNormalized = \
                      float (matrix[x,y]) / self.commitsPeriodDict[y]
                else:
                    commitsNormalized = 0
                filehand.write (str(x) + ' ' + str(y) + ' ' \
                                + str(commitsNormalized) \
                                + '\n')
            filehand.write ('\n')

        filehand.close()

        self.plot (file + '-normal')

    def plot (self, filename):
        kws = { 'close_fds': True,
                'stdin'    : subprocess.PIPE,
                'stdout'   : subprocess.PIPE,
                'stderr'   : None,
                'env'      : os.environ.copy ()
        }

        cmd = find_program ("gnuplot")
        if cmd is None:
            sys.stderr.write ('Error: gnuplot was not found in PATH\n')
            return

        try:
            p = subprocess.Popen (cmd, **kws)
        except OSError, e:
            sys.stderr.write ('Error running gnuplot: %s\n' % str (e))
            return

        iin = "unset contour\n" + \
              "set pm3d\n" + \
              "unset surface\n" + \
              "set ticslevel 0\n" + \
              "set xlabel \"Periods\"\n" + \
              "set ylabel \"History (periods)\"\n" + \
              "set zlabel \"Commits\"\n" + \
              "set terminal png\n"

        iin += "set output \"%s\"\n" % (filename + ".png") 
        iin += "splot \"%s\" with lines\n" % (filename)

        try:
            out, err = p.communicate (iin)
        except KeyboardInterrupt:
            try:
                os.kill (p.pid, signal.SIGINT)
            except OSError:
                pass


if __name__ == '__main__':
    import sys

    long_opts = ["db-output-user=", "db-output-password=", "db-output-hostname=", "db-output-database=" ]

    ctx = DBOptionContext ()
    opts, args = ctx.parse_options (sys.argv[1:], None, long_opts)

    user = passwd = database = None
    hostname = 'localhost'
    outputdir = '/tmp/generations'
    for opt, value in opts:
        if opt in ("--db-output-user",):
            user = value
        elif opt in ("--db-output-password",):
            passwd = value
        elif opt in ("--db-output-hostname",):
            hostname = value
        elif opt in ("--db-output-database",):
            database = value
        elif opt in ("--output-dir", "-o"):
            outputdir = value

    driver = ctx.get_driver ()
        
    if driver == 'sqlite':
        conn_uri =  driver + ':' + database
    elif passwd is not None:
        conn_uri = driver + '://' + user + ':' + passwd + '@' + hostname + '/' + database
    else:
        conn_uri = driver + '://' + user + '@' + hostname + '/' + database

    in_db = ctx.create_database ()
    out_db = create_database (conn_uri)

    # FIXME: this should be provided as an option
    gen = generations (in_db, out_db, outputdir, periodSlots(10))
    gen = generations (in_db, out_db, outputdir, periodDays(300))
    gen = generations (in_db, out_db, outputdir, periodDays(200))
    gen = generations (in_db, out_db, outputdir, periodQuarter())
    
